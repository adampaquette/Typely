//HintName: Code.g.cs
// <auto-generated>This file was generated by Typely.</auto-generated>
using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Text.Json.Serialization;
using Typely.Core;
using Typely.Core.Converters;

#nullable enable

namespace Typely.Generators.Tests.Typely.Configurations
{
    [JsonConverter(typeof(TypelyJsonConverter<string, Code>))]
    public partial struct Code : ITypelyValue<string, Code>, IEquatable<Code>, IComparable<Code>, IComparable
    {
        public string Value { get; private set; }

        public Code() => throw new Exception("Parameterless constructor is not allowed.");

        public Code(string value)
        {
            TypelyValue.ValidateAndThrow<string, Code>(value);
            Value = value;
        }

        public static ValidationError? Validate(string value)
        {
            if (value == null) throw new ArgumentNullException(nameof(Code));

            if (value.Length != 4)
            {
                return ValidationErrorFactory.Create(value, "ExactLength", ErrorMessages.ExactLength, "Code",
                    new Dictionary<string, object?>
                    {
                        { "ExactLength", 4 },
                    });
            }

            if (value.Equals("0000"))
            {
                return ValidationErrorFactory.Create(value, "NotEqual", ErrorMessages.NotEqual, "Code",
                    new Dictionary<string, object?>
                    {
                        { "ComparisonValue", "0000" },
                    });
            }

            return null;
        }

        public static Code From(string value) => new(value);

        public static bool TryFrom(string value, [MaybeNullWhen(false)] out Code typelyType, out ValidationError? validationError)
        {
            validationError = Validate(value);
            var isValid = validationError == null;
            typelyType = default;
            if (isValid)
            {
                typelyType.Value = value;
            }
            return isValid;
        }

        public override string ToString() => Value.ToString();

        public static bool operator !=(Code left, Code right) => !(left == right);

        public static bool operator ==(Code left, Code right) => left.Equals(right);

        public override int GetHashCode() => Value.GetHashCode();

        public bool Equals(Code other) => Value.Equals(other.Value);

        public override bool Equals([NotNullWhen(true)] object? obj) => obj is Code && Equals((Code)obj);

        public int CompareTo(Code other) => Value.CompareTo(other.Value);

        public int CompareTo(object? obj) => obj is not Code ? 1 : CompareTo((Code)obj!);

        public static explicit operator string(Code value) => value.Value;
    }
}