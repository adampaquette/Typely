using AgileObjects.ReadableExpressions;
using Microsoft.CodeAnalysis;
using System.Linq.Expressions;
using System.Text;
using Typely.Generators.Typely.Parsing;

namespace Typely.Generators.Typely.Emetting;

internal class Emitter
{
    private readonly Action<Diagnostic> _reportDiagnostic;
    private readonly CancellationToken _cancellationToken;

    public Emitter(Action<Diagnostic> reportDiagnostic, CancellationToken cancellationToken)
    {
        _reportDiagnostic = reportDiagnostic;
        _cancellationToken = cancellationToken;
    }

    public string Emit(EmittableType t)
    {
        if (t.Name == null)
        {
            //TODO DIAGNOSTIC
            return string.Empty;
        }

        if (t.TypeName == null)
        {
            //TODO DIAGNOSTIC
            return string.Empty;
        }

        var typeName = t.TypeName;
        var underlyingType = t.UnderlyingType!.Name.ToLower();
        var constructType = GetConstructType(t.ConstructTypeKind);
        var validationBlock = GenerateValidations(t.Rules, t.Name, t.UnderlyingType, typeName);

        return $$"""
            // <auto-generated>This file was generated by Typely.</auto-generated>
            using Typely.Core;
            using Typely.Core.Converters;
            using System.Diagnostics.CodeAnalysis;
            using System.Text.Json.Serialization;

            #nullable enable

            namespace {{t.Namespace}}
            {
                [JsonConverter(typeof(TypelyJsonConverter<{{underlyingType}}, {{typeName}}>))]
                public partial {{constructType}} {{typeName}} : ITypelyValue<{{underlyingType}}, {{typeName}}>, IEquatable<{{typeName}}>, IComparable<{{typeName}}>, IComparable
                {
                    public {{underlyingType}} Value { get; private set; }

                    public {{typeName}}() => throw new Exception("Parameterless constructor is not allowed.");

                    public {{typeName}}({{underlyingType}} value)
                    {
                        TypelyValue.ValidateAndThrow<{{underlyingType}}, {{typeName}}>(value);
                        Value = value;
                    }

                    public static ValidationError? Validate({{underlyingType}} value){{validationBlock}}

                    public static {{typeName}} From({{underlyingType}} value) => new(value);

                    public static bool TryFrom({{underlyingType}} value, [MaybeNullWhen(false)] out {{typeName}} typelyType, out ValidationError? validationError)
                    {
                        validationError = Validate(value);
                        var isValid = validationError == null;
                        typelyType = default;
                        if (isValid)
                        {
                            typelyType.Value = value;
                        }
                        return isValid;
                    }

                    public override string ToString() => Value.ToString();

                    public static bool operator !=({{typeName}} left, {{typeName}} right) => !(left == right);

                    public static bool operator ==({{typeName}} left, {{typeName}} right) => left.Equals(right);

                    public override int GetHashCode() => Value.GetHashCode();

                    public bool Equals({{typeName}} other) => Value.Equals(other.Value);

                    public override bool Equals([NotNullWhen(true)] object? obj) => obj is {{typeName}} && Equals(({{typeName}})obj);

                    public int CompareTo({{typeName}} other) => Value.CompareTo(other.Value);

                    public int CompareTo(object? obj) => obj is not {{typeName}} ? 1 : CompareTo(({{typeName}})obj!);

                    public static explicit operator {{underlyingType}}({{typeName}} value) => value.Value;
                }
            }
            """;
    }

    public string GetConstructType(ConstructTypeKind objectType) => objectType switch
    {
        ConstructTypeKind.Struct => "struct",
        ConstructTypeKind.Class => "class",
        _ => throw new ArgumentOutOfRangeException(nameof(objectType), $"Unexpected value {objectType}"),
    };

    public string GenerateValidations(List<EmittableRule> emittableValidations, Expression<Func<string>> nameExpression, Type underlyingType, string typeName)
    {
        if (!emittableValidations.Any() && underlyingType.IsValueType)
        {
            return " => null;";
        }

        var builder = new StringBuilder(Environment.NewLine);
        builder.AppendLine("        {");

        if(!underlyingType.IsValueType)
        {
            builder.AppendLine($"            if (value == null) throw new ArgumentNullException(nameof({typeName}));")
                .AppendLine();
        }

        foreach (var emittableValidation in emittableValidations)
        {
            _cancellationToken.ThrowIfCancellationRequested();
            var validation = GenerateValidation(emittableValidation);
            if (validation == null)
            {
                continue;
            }

            var errorCode = emittableValidation.ErrorCode;
            var name = nameExpression.Body.ToReadableString();
            var validationMessage = emittableValidation.Message.Body.ToReadableString();
            var placeholders = GenerateValidationPlaceholders(emittableValidation.PlaceholderValues);

            builder.AppendLine($$"""
                            if ({{validation}})
                            {
                                return ValidationErrorFactory.Create(value, "{{errorCode}}", {{validationMessage}}, {{name}}{{placeholders}}
                            }
                """)
                .AppendLine();
        }

        builder
            .AppendLine("            return null;")
            .Append("        }");

        return builder.ToString();
    }

    private static string? GenerateValidation(EmittableRule emittableValidation)
    {
        var validationExpression = emittableValidation.Rule as LambdaExpression;
        if (validationExpression == null)
        {
            //TODO diagnostic unsupported expression
            return null;
        }

        if (validationExpression.Parameters.Count != 1)
        {
            //TODO new diagnostic
            return null;
        }

        var parameterModifier = new ValidationParameterModifier(validationExpression.Parameters[0]);
        var modifiedValidationExpression = (LambdaExpression)parameterModifier.Modify(validationExpression);
        return modifiedValidationExpression.Body.ToReadableString();
    }

    private static string GenerateValidationPlaceholders(Dictionary<string, object?> placeholders)
    {
        if (!placeholders.Any())
        {
            return ");";
        }

        var builder = new StringBuilder("""
            ,
                                new Dictionary<string, object?>
                                {
            """)
            .AppendLine();

        foreach (var placeholder in placeholders)
        {
            var value = Expression.Constant(placeholder.Value).ToReadableString();
            builder.AppendLine($$"""                        { "{{placeholder.Key}}", {{value}} },""");
        }

        return builder.Append("                    });")
            .ToString();
    }
}