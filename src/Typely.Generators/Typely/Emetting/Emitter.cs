using AgileObjects.ReadableExpressions;
using Microsoft.CodeAnalysis;
using System.Linq.Expressions;
using System.Text;
using Typely.Generators.Typely.Parsing;

namespace Typely.Generators.Typely.Emetting;

internal class Emitter
{
    private readonly Action<Diagnostic> _reportDiagnostic;
    private readonly CancellationToken _cancellationToken;

    public Emitter(Action<Diagnostic> reportDiagnostic, CancellationToken cancellationToken)
    {
        _reportDiagnostic = reportDiagnostic;
        _cancellationToken = cancellationToken;
    }

    public string Emit(EmittableType t)
    {
        var underlyingType = t.UnderlyingType!.Name;
        var constructType = GetConstructType(t.ConstructTypeKind);
        var validationBlock = GenerateValidations(t.Validations, t.Name);

        return $$"""
            // <auto-generated> This file was generated by Typely.</auto-generated>
            using Typely.Core;
            using Typely.Core.Converters;
            using System.Diagnostics.CodeAnalysis;
            using System.Text.Json.Serialization;

            #nullable enable

            namespace {{t.Namespace}}
            {
                [JsonConverter(typeof(TypelyJsonConverter<{{underlyingType}}, {{t.TypeName}}>))]
                public partial {{constructType}} {{t.TypeName}} : ITypelyValue<{{underlyingType}}, {{t.TypeName}}>
                {
                    public {{underlyingType}} Value { get; private set; }

                    public {{t.TypeName}}() => throw new Exception("Parameterless constructor is not allowed.");

                    public {{t.TypeName}}({{underlyingType}} value)
                    {
                        TypelyValue.ValidateAndThrow<{{underlyingType}}, {{t.TypeName}}>(value);
                        Value = value;
                    }

                    public static ValidationError? Validate({{underlyingType}} value) {{validationBlock}}

                    public static {{t.TypeName}} From({{underlyingType}} value) => new(value);

                    public static bool TryFrom({{underlyingType}} value, [MaybeNullWhen(false)] out {{t.TypeName}} typelyType, out ValidationError? validationError)
                    {
                        validationError = Validate(value);
                        var isValid = validationError == null;
                        typelyType = default;
                        if (isValid)
                        {
                            typelyType.Value = value;
                        }
                        return isValid;
                    }
                }
            }
            """;
    }

    public string GetConstructType(ConstructTypeKind objectType) => objectType switch
    {
        ConstructTypeKind.Struct => "struct",
        ConstructTypeKind.Record => "record",
        ConstructTypeKind.Class => "class",
        _ => throw new ArgumentOutOfRangeException(nameof(objectType), $"Unexpected value {objectType}"),
    };

    public string GenerateValidations(List<EmittableValidation> emittableValidations, string name)
    {
        if (!emittableValidations.Any())
        {
            return "=> null;";
        }

        var builder = new StringBuilder(Environment.NewLine);
        builder.Append("        {").Append(Environment.NewLine);

        foreach (var emittableValidation in emittableValidations)
        {
            _cancellationToken.ThrowIfCancellationRequested();
            var validation = CreateCSharpValidation(emittableValidation);
            if (validation == null)
            {
                continue;
            }

            var errorCode = emittableValidation.ErrorCode;
            var validationMessage = emittableValidation.ValidationMessage.Body.ToReadableString();

            builder.Append($$"""
                            if ({{validation}})
                            {
                                return ValidationErrorFactory.Create(value, {{errorCode}}, {{validationMessage}}, {{name}}, placeholderValues);
                            }
                """);
        }

        builder.Append(Environment.NewLine)
            .Append("        }")
            .Append(Environment.NewLine);

        return builder.ToString();
    }

    private static string? CreateCSharpValidation(EmittableValidation emittableValidation)
    {
        var lambda = emittableValidation.Validation as LambdaExpression;
        if (lambda == null)
        {
            //diagnostic unsupported expression
            return null;
        }

        if (lambda.Parameters.Count != 1)
        {
            //new diagnostic
            return null;
        }

        var parameterModifier = new ValidationParameterModifier(lambda.Parameters[0]);
        var validationExpression = (LambdaExpression)parameterModifier.Modify(lambda);
        return validationExpression.Body.ToReadableString();
    }
}