using AgileObjects.ReadableExpressions;
using System.Linq.Expressions;
using System.Text;
using Typely.Generators.Typely.Parsing;

namespace Typely.Generators.Typely.Emetting;

internal class Emitter
{
    public string Emit(EmittableType t)
    {
        var underlyingType = t.UnderlyingType!.Name;
        var objectType = GetObjectType(t.TypeKind);
        var validationBlock = GenerateValidations(t.Validations);

        return $$"""
            // <auto-generated> This file was generated by Typely.</auto-generated>
            using Typely.Core;
            using Typely.Core.Converters;
            using System.Diagnostics.CodeAnalysis;
            using System.Text.Json.Serialization;

            #nullable enable

            namespace {{t.Namespace}}
            {
                [JsonConverter(typeof(TypelyJsonConverter<{{underlyingType}}, {{t.TypeName}}>))]
                public partial {{objectType}} {{t.TypeName}} : ITypelyValue<{{underlyingType}}, {{t.TypeName}}>
                {
                    public {{underlyingType}} Value { get; private set; }

                    public {{t.TypeName}}() => throw new Exception("Parameterless constructor is not allowed.");

                    public {{t.TypeName}}({{underlyingType}} value)
                    {
                        TypelyValue.ValidateAndThrow<{{underlyingType}}, {{t.TypeName}}>(value);
                        Value = value;
                    }

                    public static ValidationError? Validate({{underlyingType}} value) {{validationBlock}}

                    public static {{t.TypeName}} From({{underlyingType}} value) => new(value);

                    public static bool TryFrom({{underlyingType}} value, [MaybeNullWhen(false)] out {{t.TypeName}} typelyType, out ValidationError? validationError)
                    {
                        validationError = Validate(value);
                        var isValid = validationError == null;
                        typelyType = default;
                        if (isValid)
                        {
                            typelyType.Value = value;
                        }
                        return isValid;
                    }
                }
            }
            """;
    }

    public string GetObjectType(TypeKind objectType) => objectType switch
    {
        TypeKind.Struct => "struct",
        TypeKind.Record => "record",
        TypeKind.Class => "class",
        _ => throw new ArgumentOutOfRangeException(nameof(objectType), $"Unexpected value {objectType}"),
    };

    public string GenerateValidations(List<EmittableValidation> validations)
    {
        if (!validations.Any())
        {
            return "=> null;";
        }

        var builder = new StringBuilder(Environment.NewLine);
        builder.Append("        {").Append(Environment.NewLine);

        foreach (var validation in validations)
        {
            var lambda = validation.ValidationExpression as LambdaExpression;
            if (lambda == null)
            {
                //diagnostic unsupported expression
                continue;
            }

            if (lambda.Parameters.Count != 1)
            {
                //new diagnostic
                continue;
            }

            var parameterModifier = new ValidationParameterModifier(lambda.Parameters[0]);
            var validationExpression = (LambdaExpression)parameterModifier.Modify(lambda);

            builder.Append($$"""
                            if ({{validationExpression.Body.ToReadableString()}})
                            {
                
                            }
                """);
        }

        builder.Append(Environment.NewLine)
            .Append("        }")
            .Append(Environment.NewLine);

        return builder.ToString();
    }
}