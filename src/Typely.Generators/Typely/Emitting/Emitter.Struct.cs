using Typely.Generators.Typely.Parsing;

namespace Typely.Generators.Typely.Emitting;

internal static partial class Emitter
{
    private static string EmitStruct(EmittableType emittableType)
    {
        var typeName = emittableType.TypeName!;
        var namespaces = BuildNamespaces(emittableType);
        var underlyingType = emittableType.UnderlyingType;
        var validationBlock = GenerateValidations(emittableType);
        var tryParseIfPresent = GenerateTryParseIfSupported(emittableType);
        var safeNormalize = GenerateSafeNormalize(emittableType);
        var maxLengthInterface = GenerateMaxLengthInterface(emittableType);
        var properties = GenerateProperties(emittableType);
        var interrogationPoint = emittableType.IsValueType ? string.Empty : "?";
        var falseCoalescing = emittableType.IsValueType ? string.Empty : " ?? false";
        var oneCoalescing = emittableType.IsValueType ? string.Empty : " ?? 1";
        
        return $$"""
            // <auto-generated>This file was generated by Typely.</auto-generated>
            {{namespaces}}

            #nullable enable

            namespace {{emittableType.Namespace}}
            {
                [TypeConverter(typeof(TypelyTypeConverter<{{underlyingType}}, {{typeName}}>))]
                [JsonConverter(typeof(TypelyJsonConverter<{{underlyingType}}, {{typeName}}>))]
                public readonly partial struct {{typeName}} : ITypelyValue<{{underlyingType}}, {{typeName}}>, IEquatable<{{typeName}}>, IComparable<{{typeName}}>, IComparable{{maxLengthInterface}}
                {{{properties}}
                    public {{underlyingType}} Value { get; init; }

                    private {{typeName}}({{underlyingType}} value, bool byPassValidation)
                    {
                        Value = value;
                    }
            
                    public {{typeName}}({{underlyingType}} value)
                    {
                        {{safeNormalize}}TypelyValue.ValidateAndThrow<{{underlyingType}}, {{typeName}}>(value);
                        Value = value;
                    }

                    public static ValidationError? Validate({{underlyingType}} value){{validationBlock}}

                    public static {{typeName}} From({{underlyingType}} value) => new(value);

                    public static bool TryFrom({{underlyingType}} value, out {{typeName}} typelyType, out ValidationError? validationError)
                    {
                        {{safeNormalize}}validationError = Validate(value);
                        var isValid = validationError == null;
                        typelyType = isValid ? new(value, true) : default;
                        return isValid;
                    }
                    {{tryParseIfPresent}}
                    public override string ToString() => Value.ToString();

                    public static bool operator !=({{typeName}} left, {{typeName}} right) => !(left == right);

                    public static bool operator ==({{typeName}} left, {{typeName}} right) => left.Equals(right);

                    public override int GetHashCode() => Value.GetHashCode();

                    public bool Equals({{typeName}} other) => Value{{interrogationPoint}}.Equals(other.Value){{falseCoalescing}};

                    public override bool Equals([NotNullWhen(true)] object? obj) => obj is {{typeName}} && Equals(({{typeName}})obj);

                    public int CompareTo({{typeName}} other) => Value{{interrogationPoint}}.CompareTo(other.Value){{oneCoalescing}};

                    public int CompareTo(object? obj) => obj is not {{typeName}} ? 1 : CompareTo(({{typeName}})obj!);

                    public static explicit operator {{underlyingType}}({{typeName}} value) => value.Value;
                }
            }
            """;
    }
}