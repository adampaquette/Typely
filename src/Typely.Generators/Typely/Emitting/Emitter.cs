using Microsoft.CodeAnalysis;
using System.Text;
using Typely.Generators.Typely.Parsing;

namespace Typely.Generators.Typely.Emitting;

/// <summary>
/// Generate the C# code for a value object.
/// </summary>
internal class Emitter
{
    public const string ValueParameterName = "value";

    private readonly Action<Diagnostic> _reportDiagnostic;
    private readonly CancellationToken _cancellationToken;

    public Emitter(Action<Diagnostic> reportDiagnostic, CancellationToken cancellationToken)
    {
        _reportDiagnostic = reportDiagnostic;
        _cancellationToken = cancellationToken;
    }

    public string Emit(EmittableType t)
    {
        if (t.Name == null)
        {
            return string.Empty;
        }

        if (t.TypeName == null)
        {
            return string.Empty;
        }

        var typeName = t.TypeName;
        var namespaces = BuildNamespaces(t.Rules, t.AdditionalNamespaces);
        var underlyingType = t.UnderlyingType;
        var constructType = GetConstructType(t.ConstructTypeKind);
        var validationBlock = GenerateValidations(t, typeName);

        return $$"""
            // <auto-generated>This file was generated by Typely.</auto-generated>
            {{namespaces}}

            #nullable enable

            namespace {{t.Namespace}}
            {
                [TypeConverter(typeof(TypelyTypeConverter<{{underlyingType}}, {{typeName}}>))]
                [JsonConverter(typeof(TypelyJsonConverter<{{underlyingType}}, {{typeName}}>))]
                public partial {{constructType}} {{typeName}} : ITypelyValue<{{underlyingType}}, {{typeName}}>, IEquatable<{{typeName}}>, IComparable<{{typeName}}>, IComparable
                {
                    public {{underlyingType}} Value { get; private set; }                    

                    public {{typeName}}({{underlyingType}} value)
                    {
                        TypelyValue.ValidateAndThrow<{{underlyingType}}, {{typeName}}>(value);
                        Value = value;
                    }

                    public static ValidationError? Validate({{underlyingType}} value){{validationBlock}}

                    public static {{typeName}} From({{underlyingType}} value) => new(value);

                    public static bool TryFrom({{underlyingType}} value, [MaybeNullWhen(false)] out {{typeName}} typelyType, out ValidationError? validationError)
                    {
                        validationError = Validate(value);
                        var isValid = validationError == null;
                        typelyType = default;
                        if (isValid)
                        {
                            typelyType.Value = value;
                        }
                        return isValid;
                    }

                    public override string ToString() => Value.ToString();

                    public static bool operator !=({{typeName}} left, {{typeName}} right) => !(left == right);

                    public static bool operator ==({{typeName}} left, {{typeName}} right) => left.Equals(right);

                    public override int GetHashCode() => Value.GetHashCode();

                    public bool Equals({{typeName}} other) => Value.Equals(other.Value);

                    public override bool Equals([NotNullWhen(true)] object? obj) => obj is {{typeName}} && Equals(({{typeName}})obj);

                    public int CompareTo({{typeName}} other) => Value.CompareTo(other.Value);

                    public int CompareTo(object? obj) => obj is not {{typeName}} ? 1 : CompareTo(({{typeName}})obj!);

                    public static explicit operator {{underlyingType}}({{typeName}} value) => value.Value;
                }
            }
            """;
    }

    private string BuildNamespaces(IList<EmittableRule> rules, IEnumerable<string> additionalNamespaces)
    {
        var namespaces = new List<string>
        {
            "System",
            "System.ComponentModel",
            "System.Diagnostics.CodeAnalysis",
            "System.Text.Json.Serialization",
            "Typely.Core",
            "Typely.Core.Converters",
        };

        namespaces.AddRange(additionalNamespaces);

        if (rules.Any())
        {
            namespaces.Add("System.Collections.Generic");
        }

        return string.Join("\n", namespaces.Distinct().OrderBy(x => x).Select(x => $"using {x};"));
    }

    private string GetConstructType(ConstructTypeKind objectType) => objectType switch
    {
        ConstructTypeKind.Struct => "struct",
        _ => "class"
    };

    private string GenerateValidations(EmittableType emittableType, string typeName)
    {
        if (!emittableType.Rules.Any() && emittableType.IsValueType)
        {
            return " => null;";
        }

        var builder = new StringBuilder("\n");
        builder.AppendLine("        {");

        if (!emittableType.IsValueType)
        {
            builder.AppendLine($"            if (value == null) throw new ArgumentNullException(nameof({typeName}));")
                .AppendLine();
        }

        foreach (var rule in emittableType.Rules)
        {
            _cancellationToken.ThrowIfCancellationRequested();
            var errorCode = rule.ErrorCode;
            var placeholders = GenerateValidationPlaceholders(rule.PlaceholderValues);

            builder.AppendLine($$"""
                            if ({{rule.Rule}})
                            {
                                return ValidationErrorFactory.Create(value, "{{errorCode}}", {{rule.Message}}, {{emittableType.Name}}{{placeholders}}
                            }
                """)
                .AppendLine();
        }

        builder
            .AppendLine("            return null;")
            .Append("        }");

        return builder.ToString();
    }

    private static string GenerateValidationPlaceholders(Dictionary<string, object?> placeholders)
    {
        if (!placeholders.Any())
        {
            return ");";
        }

        var builder = new StringBuilder("""
            ,
                                new Dictionary<string, object?>
                                {
            """)
            .AppendLine();

        foreach (var placeholder in placeholders)
        {
            builder.AppendLine($$"""                        { "{{placeholder.Key}}", {{placeholder.Value}} },""");
        }

        return builder.Append("                    });")
            .ToString();
    }
}