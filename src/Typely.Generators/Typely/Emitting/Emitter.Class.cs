using Typely.Generators.Typely.Parsing;

namespace Typely.Generators.Typely.Emitting;

internal static partial class Emitter
{
    private static string EmitClass(EmittableType emittableType)
    {
        var typeName = emittableType.TypeName!;
        var namespaces = BuildNamespaces(emittableType);
        var underlyingType = emittableType.UnderlyingType;
        var validationBlock = GenerateValidations(emittableType);
        var tryParseIfPresent = GenerateTryParseIfSupported(emittableType);
        var safeNormalize = GenerateSafeNormalize(emittableType);
        var maxLengthInterface = GenerateMaxLengthInterface(emittableType);
        var properties = GenerateProperties(emittableType);

        return $$"""
            // <auto-generated>This file was generated by Typely.</auto-generated>
            {{namespaces}}

            #nullable enable

            namespace {{emittableType.Namespace}}
            {
                [TypeConverter(typeof(TypelyTypeConverter<{{underlyingType}}, {{typeName}}>))]
                [JsonConverter(typeof(TypelyJsonConverter<{{underlyingType}}, {{typeName}}>))]
                public partial class {{typeName}} : ITypelyValue<{{underlyingType}}, {{typeName}}>, IEquatable<{{typeName}}>, IComparable<{{typeName}}>, IComparable{{maxLengthInterface}}
                {{{properties}}
                    public {{underlyingType}} Value { get;  }

                    private {{typeName}}({{underlyingType}} value, bool bypassValidation)
                    {
                        Value = value;
                    }

                    public {{typeName}}({{underlyingType}} value)
                    {
                        {{safeNormalize}}TypelyValue.ValidateAndThrow<{{underlyingType}}, {{typeName}}>(value);
                        Value = value;
                    }

                    public static ValidationError? Validate({{underlyingType}} value){{validationBlock}}

                    public static {{typeName}} From({{underlyingType}} value) => new(value);

                    public static bool TryFrom({{underlyingType}} value, out {{typeName}}? typelyType, out ValidationError? validationError)
                    {
                        {{safeNormalize}}validationError = Validate(value);
                        var isValid = validationError == null;

                        typelyType = isValid ? new {{typeName}}(value, true) : null;

                        return isValid;
                    }
                    {{tryParseIfPresent}}
                    public override string ToString() => Value.ToString();

                    public static bool operator !=({{typeName}}? left, {{typeName}}? right) => !(left == right);

                    public static bool operator ==({{typeName}}? left, {{typeName}}? right) => left?.Equals(right) ?? false;

                    public override int GetHashCode() => Value.GetHashCode();

                    public bool Equals({{typeName}}? other)
                    {
                        if(ReferenceEquals(this, other))
                        {
                            return true;
                        }

                        return !ReferenceEquals(other, null) && Value.Equals(other.Value);
                    }

                    public override bool Equals([NotNullWhen(true)] object? obj) => obj is {{typeName}} type && Equals(type);

                    public int CompareTo({{typeName}}? other) => ReferenceEquals(other, null) ? 1 : Value.CompareTo(other.Value);
                                                                                        
                    public int CompareTo(object? obj) => obj is not {{typeName}} type ? 1 : CompareTo(type);

                    public static explicit operator {{underlyingType}}({{typeName}} value) => value.Value;
                }
            }
            """;
    }
}